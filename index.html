<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ZeroKnocks</title>
  <meta name="description" content="A calm, precise unit conversion tool. Ten converters, zero friction.">
  <meta property="og:title" content="ZeroKnocks">
  <meta property="og:description" content="A calm, precise unit conversion tool.">
  <meta property="og:type" content="website">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><rect fill=%22%2309090b%22 width=%22100%22 height=%22100%22 rx=%2218%22/><text x=%2250%22 y=%2272%22 text-anchor=%22middle%22 fill=%22%23b8975f%22 font-size=%2258%22 font-family=%22monospace%22 font-weight=%22bold%22>0</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=DM+Sans:opsz,wght@9..40,300;9..40,400;9..40,500&display=swap" rel="stylesheet">

  <style>
    /*
     * DESIGN SYSTEM
     * Near-black canvas, warm bronze accent. JetBrains Mono for values
     * (weight 500 for legibility on dark bg), DM Sans for labels.
     * Side-by-side converter layout: LEFT ⇄ RIGHT reads naturally.
     * Hairline grid dividers via 1px gap on colored background.
     */

    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg:            #08080a;
      --surface:       #101013;
      --surface-hover: #151518;
      --border:        #1e1e24;
      --text-1:        #ececef;
      --text-2:        #88888f;
      --text-3:        #505058;
      --accent:        #b8975f;
      --mono:          'JetBrains Mono', 'Menlo', monospace;
      --sans:          'DM Sans', system-ui, sans-serif;
    }

    html, body {
      height: 100%;
      background: var(--bg);
      color: var(--text-1);
      font-family: var(--sans);
      -webkit-font-smoothing: antialiased;
    }

    body {
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* ── Brand ── */

    .header {
      height: 2.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .brand {
      font-family: var(--mono);
      font-size: 0.85rem;
      font-weight: 500;
      letter-spacing: 0.35em;
      text-transform: uppercase;
      color: var(--text-1);
    }


    /* ── Grid: 5 cols × 2 rows, hairline dividers ── */

    .grid {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 1px;
      background: var(--border);
      border-top: 1px solid var(--border);
    }

    /* ── Tile ── */

    .tile {
      background: var(--surface);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 1rem 0.6rem;
      position: relative;
      transition: background 0.2s ease;
      opacity: 0;
      animation: tile-in 0.4s ease forwards;
    }

    .tile:hover {
      background: var(--surface-hover);
    }

    .tile:focus-within {
      background: var(--surface-hover);
    }

    @keyframes tile-in {
      from { opacity: 0; transform: translateY(6px); }
      to   { opacity: 1; transform: translateY(0); }
    }

    /* ── Category label ── */

    .cat {
      position: absolute;
      top: 0.5rem;
      left: 0.6rem;
      font-size: 0.58rem;
      font-weight: 500;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--text-1);
    }

    /* ── Side-by-side converter pair ── */

    .pair {
      display: flex;
      align-items: flex-start;
      justify-content: center;
      gap: 0.35rem;
      width: 100%;
    }

    .side {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-width: 0;
    }

    .side input {
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--text-1);
      font-family: var(--mono);
      font-size: 1.5rem;
      font-weight: 500;
      text-align: center;
      width: 100%;
      padding: 0.15rem 0;
      caret-color: var(--accent);
      transition: border-color 0.2s ease;
    }

    .side input:focus {
      outline: none;
      border-bottom-color: var(--accent);
    }

    /* ── Unit label ── */

    .unit {
      font-family: var(--sans);
      font-size: 0.7rem;
      font-weight: 400;
      color: var(--text-2);
      margin-top: 0.25rem;
      user-select: none;
    }

    /* Cyclable unit (data converter) — click to cycle B/KB/MB/GB */
    .unit.cyclable {
      cursor: pointer;
      border-bottom: 1px dashed var(--text-3);
      padding-bottom: 2px;
      transition: color 0.15s ease, border-color 0.15s ease;
    }

    .unit.cyclable:hover,
    .unit.cyclable:focus-visible {
      color: var(--text-1);
      border-bottom-color: var(--accent);
    }

    /* ── Midpoint separator (⇄) ── */

    .mid {
      color: var(--text-3);
      font-size: 0.75rem;
      flex-shrink: 0;
      padding-top: 0.3rem;
      user-select: none;
    }

    /* ── Noscript ── */

    noscript p {
      color: var(--text-2);
      text-align: center;
      padding: 3rem;
      font-size: 0.8rem;
    }

    /* ─────────────────────────────────
     * RESPONSIVE BREAKPOINTS
     * ≥1280 → 5×2, no scroll
     * ≥1024 → 5×2 tighter
     * ≥768  → 3 columns
     * ≥480  → 2 columns
     * <480  → 1 column
     * ───────────────────────────────── */

    @media (max-width: 1279px) {
      .side input { font-size: 1.15rem; }
      .tile { padding: 0.75rem 0.4rem; }
      .unit { font-size: 0.6rem; }
      .pair { gap: 0.25rem; }
    }

    @media (max-width: 1023px) {
      body { overflow: auto; }
      .grid {
        grid-template-columns: repeat(3, 1fr);
        grid-template-rows: auto;
      }
      .tile {
        padding: 1.5rem 1rem;
        min-height: 150px;
      }
      .side input { font-size: 1.4rem; }
      .unit { font-size: 0.7rem; }
      .pair { gap: 0.5rem; }
    }

    @media (max-width: 767px) {
      .grid { grid-template-columns: repeat(2, 1fr); }
      .tile { padding: 1.75rem 1rem; }
      .side input { font-size: 1.5rem; }
    }

    @media (max-width: 479px) {
      .grid { grid-template-columns: 1fr; }
      .tile { padding: 1.5rem 1.25rem; min-height: 130px; }
      .side input { font-size: 1.6rem; }
      .pair { gap: 0.75rem; }
    }
  </style>
</head>

<body>
  <header class="header">
    <h1 class="brand">ZeroKnocks</h1>
  </header>

  <main class="grid" id="grid" role="main"></main>

  <noscript><p>JavaScript is required to use ZeroKnocks.</p></noscript>

  <script>
    /* ══════════════════════════════════════════════════
     *  CONVERTER DEFINITIONS
     *  Each: id, label, left [unit, default value],
     *  right [unit], toR (left→right), toL (right→left)
     * ══════════════════════════════════════════════════ */

    const converters = [
      { id: 'length',   label: 'Length',      l: ['m',    1],   r: ['ft'  ], toR: v => v * 3.28084,      toL: v => v / 3.28084 },
      { id: 'weight',   label: 'Weight',      l: ['kg',   1],   r: ['lb'  ], toR: v => v * 2.20462,      toL: v => v / 2.20462 },
      { id: 'temp',     label: 'Temperature', l: ['°C',  20],   r: ['°F'  ], toR: v => v * 9 / 5 + 32,   toL: v => (v - 32) * 5 / 9 },
      { id: 'volume',   label: 'Volume',      l: ['L',    1],   r: ['gal' ], toR: v => v * 0.264172,     toL: v => v / 0.264172 },
      { id: 'area',     label: 'Area',        l: ['m²',   1],   r: ['ft²' ], toR: v => v * 10.7639,      toL: v => v / 10.7639 },
      { id: 'speed',    label: 'Speed',       l: ['km/h',100],  r: ['mph' ], toR: v => v * 0.621371,     toL: v => v / 0.621371 },
      { id: 'energy',   label: 'Energy',      l: ['kcal',100],  r: ['kJ'  ], toR: v => v * 4.184,        toL: v => v / 4.184 },
      { id: 'power',    label: 'Power',       l: ['W',  100],   r: ['hp'  ], toR: v => v / 745.7,        toL: v => v * 745.7 },
      { id: 'pressure', label: 'Pressure',    l: ['bar',  1],   r: ['psi' ], toR: v => v * 14.5038,      toL: v => v / 14.5038 },
    ];

    /* Data converter — units are cyclable (B → KB → MB → GB) */
    const dataUnits = ['B', 'KB', 'MB', 'GB'];
    const dataBytes = { B: 1, KB: 1024, MB: 1048576, GB: 1073741824 };
    const dataState = { leftIdx: 3, rightIdx: 2 };  /* GB ⇄ MB */

    /* ── Formatting: precise but clean ── */

    function fmt(n) {
      if (n === 0) return '0';
      const a = Math.abs(n);
      if (a >= 100000) return parseFloat(n.toPrecision(6)).toString();
      if (a >= 1)      return parseFloat(n.toFixed(4)).toString();
      return parseFloat(n.toPrecision(4)).toString();
    }

    /* ── Build tiles ── */

    const grid = document.getElementById('grid');

    /* Standard converters (1–9): side-by-side layout */
    converters.forEach((c, i) => {
      const rightVal = fmt(c.toR(c.l[1]));
      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.style.animationDelay = `${i * 40}ms`;
      tile.setAttribute('role', 'group');
      tile.setAttribute('aria-label', `${c.label} converter`);
      tile.innerHTML = `
        <span class="cat">${c.label}</span>
        <div class="pair">
          <div class="side">
            <input type="text" inputmode="decimal"
                   data-id="${c.id}" data-side="left"
                   value="${c.l[1]}" aria-label="${c.l[0]} value">
            <span class="unit">${c.l[0]}</span>
          </div>
          <span class="mid">\u21C4</span>
          <div class="side">
            <input type="text" inputmode="decimal"
                   data-id="${c.id}" data-side="right"
                   value="${rightVal}" aria-label="${c.r[0]} value">
            <span class="unit">${c.r[0]}</span>
          </div>
        </div>`;
      grid.appendChild(tile);
    });

    /* Data converter (10th tile, cyclable units) */
    (function () {
      const lUnit = dataUnits[dataState.leftIdx];
      const rUnit = dataUnits[dataState.rightIdx];
      const lVal  = 1;
      const rVal  = fmt(lVal * dataBytes[lUnit] / dataBytes[rUnit]);

      const tile = document.createElement('div');
      tile.className = 'tile';
      tile.style.animationDelay = `${9 * 40}ms`;
      tile.setAttribute('role', 'group');
      tile.setAttribute('aria-label', 'Data size converter');
      tile.innerHTML = `
        <span class="cat">Data</span>
        <div class="pair">
          <div class="side">
            <input type="text" inputmode="decimal"
                   data-id="data" data-side="left"
                   value="${lVal}" aria-label="Data size value">
            <span class="unit cyclable" data-side="left"
                  role="button" tabindex="0"
                  aria-label="Cycle unit, currently ${lUnit}">${lUnit}</span>
          </div>
          <span class="mid">\u21C4</span>
          <div class="side">
            <input type="text" inputmode="decimal"
                   data-id="data" data-side="right"
                   value="${rVal}" aria-label="Data size value">
            <span class="unit cyclable" data-side="right"
                  role="button" tabindex="0"
                  aria-label="Cycle unit, currently ${rUnit}">${rUnit}</span>
          </div>
        </div>`;
      grid.appendChild(tile);
    })();

    /* ── Conversion engine ── */

    function convert(id, side, value) {
      const otherSide = side === 'left' ? 'right' : 'left';
      const target = grid.querySelector(
        `input[data-id="${id}"][data-side="${otherSide}"]`
      );

      if (id === 'data') {
        const from = dataUnits[dataState[side === 'left' ? 'leftIdx' : 'rightIdx']];
        const to   = dataUnits[dataState[side === 'left' ? 'rightIdx' : 'leftIdx']];
        target.value = fmt(value * dataBytes[from] / dataBytes[to]);
      } else {
        const c = converters.find(x => x.id === id);
        target.value = fmt(side === 'left' ? c.toR(value) : c.toL(value));
      }
    }

    /* ── Event delegation ── */

    /* Real-time conversion on every keystroke */
    grid.addEventListener('input', (e) => {
      if (e.target.tagName !== 'INPUT') return;
      const raw = e.target.value.trim();
      if (raw === '' || raw === '-' || raw === '.') {
        grid.querySelector(
          `input[data-id="${e.target.dataset.id}"][data-side="${
            e.target.dataset.side === 'left' ? 'right' : 'left'
          }"]`
        ).value = '';
        return;
      }
      const val = parseFloat(raw);
      if (!isNaN(val)) convert(e.target.dataset.id, e.target.dataset.side, val);
    });

    /* Select all on focus for quick re-entry */
    grid.addEventListener('focusin', (e) => {
      if (e.target.tagName === 'INPUT') e.target.select();
    });

    /* Data unit cycling — click */
    grid.addEventListener('click', (e) => {
      if (e.target.classList.contains('cyclable')) cycleUnit(e.target);
    });

    /* Data unit cycling — keyboard (Enter / Space) */
    grid.addEventListener('keydown', (e) => {
      if (e.target.classList.contains('cyclable') && (e.key === 'Enter' || e.key === ' ')) {
        e.preventDefault();
        cycleUnit(e.target);
      }
    });

    function cycleUnit(el) {
      const side   = el.dataset.side;
      const key    = side === 'left' ? 'leftIdx' : 'rightIdx';
      const oldIdx = dataState[key];
      const oldUnit = dataUnits[oldIdx];

      dataState[key] = (oldIdx + 1) % dataUnits.length;
      const newUnit = dataUnits[dataState[key]];
      el.textContent = newUnit;
      el.setAttribute('aria-label', `Cycle unit, currently ${newUnit}`);

      /* Re-express same quantity in new unit */
      const input = grid.querySelector(`input[data-id="data"][data-side="${side}"]`);
      const val = parseFloat(input.value);
      if (!isNaN(val)) {
        input.value = fmt(val * dataBytes[oldUnit] / dataBytes[newUnit]);
      }
    }
  </script>
</body>
</html>
